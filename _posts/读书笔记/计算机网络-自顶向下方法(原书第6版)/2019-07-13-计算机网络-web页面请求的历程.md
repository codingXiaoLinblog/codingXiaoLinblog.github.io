---
layout: post
title:  "计算机网络-web页面请求的历程"
date:   2019-07-13 16:38:30
categories: 计算机网络
tags: 计算机网络 web
author: wql
---

* content
{:toc}
从用户浏览器输入url到用户看到页面结果的过程，发生了什么事情？这是一道经典的面试题，这道面试题不光前端面试会问到，后端面试也会被问到。
这道题没有一个标准的答案，它涉及很多的知识点，面试官会通过这道题了解你对哪一方面的知识比较擅长，然后继续追问看看你的掌握程度。当然我写的这些也只是我的一些简单的理解，从前端的角度出发，我觉得首先回答必须包括几个基本的点，然后在根据你的理解深入回答。



 

# 一、web页面请求的历程

## 请求过程的概述
 
>1. URL解析
>2. 浏览器缓存
>3. DNS域名解析
>4. TCP三次握手
>5. 浏览器向服务器发送HTTP请求
>6. 浏览器接收响应
>7. 页面渲染
>8. 关闭TCP连接或继续保持连接


## 1. URL解析
我们常见的RUL是这样的:http://www.baidu.com,这个域名由三部分组成：协议名、域名、端口号，这里端口是默认所以隐藏。除此之外
URL还会包含一些路径、查询和其他片段，例如：http://www.tuicool.com/search?kw=%E4%。我们最常见的的协议是HTTP协议，除此之外
还有加密的HTTPS协议、FTP协议、FILe协议等等。URL的中间部分为域名或者是IP，之后就是端口号了。通常端口号不常见是因为大部分
的都是使用默认端口，如HTTP默认端口80，HTTPS默认端口443。说到这里可能有的面试官会问你同源策略，以及更深层次的跨域的问题，
我今天就不在这里展开了。
 
## 2. 浏览器缓存
 
　　说完URL我们说说浏览器缓存,HTTP缓存有多种规则，根据是否需要重新向服务器发起请求来分类，我将其分为强制缓存，对比缓存。

　　强制缓存判断HTTP首部字段：cache-control，Expires。

　　Expires是一个绝对时间，即服务器时间。浏览器检查当前时间，如果还没到失效时间就直接使用缓存文件。但是该方法存在一个问题：服务器时间与客户端时间可能不一致。因此该字段已经很少使用。

　　cache-control中的max-age保存一个相对时间。例如Cache-Control: max-age = 484200，表示浏览器收到文件后，缓存在484200s内均有效。 如果同时存在cache-control和Expires，浏览器总是优先使用cache-control。

　　对比缓存通过HTTP的last-modified，Etag字段进行判断。

　　last-modified是第一次请求资源时，服务器返回的字段，表示最后一次更新的时间。下一次浏览器请求资源时就发送if-modified-since字段。服务器用本地Last-modified时间与if-modified-since时间比较，如果不一致则认为缓存已过期并返回新资源给浏览器；如果时间一致则发送304状态码，让浏览器继续使用缓存。

　　Etag：资源的实体标识（哈希字符串），当资源内容更新时，Etag会改变。服务器会判断Etag是否发生变化，如果变化则返回新资源，否则返回304。

 ![缓存更新机制](/assets/cm_network/cache-control.png)
 
## 3. DNS域名解析       

　　我们知道在地址栏输入的域名并不是最后资源所在的真实位置，域名只是与IP地址的一个映射。网络服务器的IP地址那么多，我们不可能去记一串串的数字，因此域名就产生了，域名解析的过程实际是将域名还原为IP地址的过程。

　　首先浏览器先检查本地hosts文件是否有这个网址映射关系，如果有就调用这个IP地址映射，完成域名解析。

　　如果没找到则会查找本地DNS解析器缓存，如果查找到则返回。

　　如果还是没有找到则会查找本地DNS服务器，如果查找到则返回。

　　最后迭代查询，按根域服务器 ->顶级域,.cn->第二层域，hb.cn ->子域，www.hb.cn的顺序找到IP地址。

 ![DNS域名解析-1](/assets/cm_network/DNS域名解析-1.jpg)
 
 递归查询，按上一级DNS服务器->上上级->....逐级向上查询找到IP地址。
 
  ![DNS域名解析-2](/assets/cm_network/DNS域名解析-2.jpg)
  
## 4. TCP三次握手      
     
 　　在通过第一步的DNS域名解析后，获取到了服务器的IP地址，在获取到IP地址后，便会开始建立一次连接，这是由TCP协议完成的，主要通过三次握手进行连接。
 
 　　第一次握手： 建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认； 
 
 　　第二次握手： 服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；
 
 　　第三次握手： 客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。

 　　完成三次握手，客户端与服务器开始传送数据。
  
 ![TCP三次握手](/assets/cm_network/TCP三次握手.png)
 
 ![TCP三次握手](/assets/cm_network/TCP三次握手状态变化.jpg)
 
 加分的描述我觉得应该是这样：刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态。
 
 　　第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)。此时客户端处于 SYN_Send 状态。
 
 　　第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)。同时会把客户端的 ISN + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。
 
 　　第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 establised 状态。
 服务器收到 ACK 报文之后，也处于 establised 状态，此时，双方已建立起了链接。
 
 三次握手的作用
 
 三次握手的作用也是有好多的，多记住几个，保证不亏。例如：
 确认双方的接受能力、发送能力是否正常。
 指定自己的初始化序列号，为后面的可靠传送做准备。
 如果是 HTTPS 协议的话，三次握手这个过程，还会进行数字证书的验证以及加密密钥的生成。
 
 单单这样还不足以应付三次握手，面试官可能还会问一些其他的问题，例如：
 
 ①（ISN）是固定的吗
 
 三次握手的一个重要功能是客户端和服务端交换 ISN(Initial Sequence Number)，以便让对方知道接下来接收数据的时候如何按序列号组装数据。
 
 如果 ISN 是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。
 
 ②什么是半连接队列
 
 服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。
 
 当然还有一个全连接队列，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。
 
 这里在补充一点关于SYN-ACK 重传次数的问题：
 服务器发送完SYN－ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传。
 如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。
 
 注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s，2s，4s，8s......
 
 ③三次握手过程中可以携带数据吗
 
 很多人可能会认为三次握手都不能携带数据，其实第三次握手的时候，是可以携带数据的。
 
 也就是说，第一次、第二次握手不可以携带数据，而第三次握手是可以携带数据的。
 
 为什么这样呢？大家可以想一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据。
 
 因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。
 
 也就是说，第一次握手可以放数据的话，其中一个简单的原因就是会让服务器更加容易受到攻击了。
 
 而对于第三次的话，此时客户端已经处于 established 状态，也就是说，对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据页没啥毛病。
 
 
## 5. 浏览器向服务器发送HTTP请求

  完整的HTTP请求包含请求起始行、请求头部、请求主体三部分。
  
   ![HTTP请求](/assets/cm_network/HTTP请求.jpg)
 
## 6. 浏览器接收响应       
    
 　　服务器在收到浏览器发送的HTTP请求之后，会将收到的HTTP报文封装成HTTP的Request对象，并通过不同的Web服务器进行处理，处理完的结果以HTTP的Response对象返回，主要包括状态码，响应头，响应报文三个部分。
 
 　　状态码主要包括以下部分
 
 　　1xx：指示信息–表示请求已接收，继续处理。
 
 　　2xx：成功–表示请求已被成功接收、理解、接受。
 
 　　3xx：重定向–要完成请求必须进行更进一步的操作。
 
 　　4xx：客户端错误–请求有语法错误或请求无法实现。
 
 　　5xx：服务器端错误–服务器未能实现合法的请求。
 
 　　响应头主要由Cache-Control、 Connection、Date、Pragma等组成。
 
 　　响应体为服务器返回给浏览器的信息，主要由HTML，css，js，图片文件组成。
 
##  7. 页面渲染    
     
 如果说响应的内容是HTML文档的话，就需要浏览器进行解析渲染呈现给用户。整个过程涉及两个方面：解析和渲染。在渲染页面之前，需要构建DOM树和CSSOM树。
 
  ![页面渲染](/assets/cm_network/DOM树.png)
 
 在浏览器还没接收到完整的 HTML 文件时，它就开始渲染页面了，在遇到外部链入的脚本标签或样式标签或图片时，会再次发送 HTTP 请求重复上述的步骤。在收到 CSS 文件后会对已经渲染的页面重新渲染，加入它们应有的样式，图片文件加载完立刻显示在相应位置。在这一过程中可能会触发页面的重绘或重排。这里就涉及了两个重要概念：Reflow和Repaint。
 
 　　Reflow，也称作Layout，中文叫回流，一般意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树，这个过程称为Reflow。
 
 　　Repaint，中文重绘，意味着元素发生的改变只是影响了元素的一些外观之类的时候（例如，背景色，边框颜色，文字颜色等），此时只需要应用新样式绘制这个元素就OK了，这个过程称为Repaint。
 
 　　所以说Reflow的成本比Repaint的成本高得多的多。DOM树里的每个结点都会有reflow方法，一个结点的reflow很有可能导致子结点，甚至父点以及同级结点的reflow。
 
 　　下面这些动作有很大可能会是成本比较高的：
 
 增加、删除、修改DOM结点时，会导致Reflow或Repaint
 
 移动DOM的位置，或是搞个动画的时候
 
 内容发生变化
 
 修改CSS样式的时候
 
 Resize窗口的时候（移动端没有这个问题），或是滚动的时候
 
 修改网页的默认字体时
 
基本上来说，reflow有如下的几个原因：
 
>Initial，网页初始化的时候      
>Incremental，一些js在操作DOM树时          
>Resize，其些元件的尺寸变了              
>StyleChange，如果CSS的属性发生变化了         
>Dirty，几个Incremental的reflow发生在同一个frame的子树上         
 
## 8. 关闭TCP连接或继续保持连接    
    
  通过四次挥手关闭连接(FIN ACK, ACK, FIN ACK, ACK)。
  
  ![TCP四次挥手](/assets/cm_network/TCP四次挥手.png)
  
  第一次挥手是浏览器发完数据后，发送FIN请求断开连接。
  
  　　第二次挥手是服务器发送ACK表示同意，如果在这一次服务器也发送FIN请求断开连接似乎也没有不妥，但考虑到服务器可能还有数据要发送，所以服务器发送FIN应该放在第三次挥手中。
  
  　　这样浏览器需要返回ACK表示同意，也就是第四次挥手。
  
  ![TCP四次挥手](/assets/cm_network/TCP四次挥手状态变化.jpg)
  
  刚开始双方都处于 establised 状态，假如是客户端先发起关闭请求，则：
  
  　　第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。
  
  　　第二次握手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。
  
  　　第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。
  
  　　第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。
  
  需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态
  服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。
  
这里特别需要注意的就是 TIME_WAIT 这个状态了，这个是面试的高频考点，就是要理解，为什么客户端发送 ACK 之后不直接关闭，而是要等一阵子才关闭。

这其中的原因就是，要确保服务器是否已经收到了我们的 ACK 报文，如果没有收到的话，服务器会重新发 FIN 报文给客户端，客户端再次收到 ACK 报文之后，就知道之前的 ACK 报文丢失了，然后再次发送 ACK 报文。

至于 TIME_WAIT 持续的时间至少是一个报文的来回时间。一般会设置一个计时，如果过了这个计时没有再次收到 FIN 报文，则代表对方成功，就是 ACK 报文，此时处于 CLOSED 状态。

这里我给出每个状态所包含的含义，有兴趣的可以看看：

>LISTEN：侦听来自远方 TCP 端口的连接请求。     
>SYN-SENT：在发送连接请求后等待匹配的连接请求。        
>SYN-RECEIVED：在收到和发送一个连接请求后等待对连接请求的确认。      
>ESTABLISHED：代表一个打开的连接，数据可以传送给用户。       
>FIN-WAIT-1：等待远程 TCP 的连接中断请求，或先前的连接中断请求的确认。         
>FIN-WAIT-2：从远程 TCP 等待连接中断请求。           
>CLOSE-WAIT：等待从本地用户发来的连接中断请求。           
>CLOSING：等待远程 TCP 对连接中断的确认。         
>LAST-ACK：等待原来发向远程 TCP 的连接中断请求的确认。          
>TIME-WAIT：等待足够的时间以确保远程 TCP 接收到连接中断请求的确认。           
>CLOSED：没有任何连接状态。           

 
 参考资料：
 - [从输入url到页面加载完成发生了什么？](https://www.cnblogs.com/daijinxue/p/6640153.html) 













